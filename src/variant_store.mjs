// Generated by CoffeeScript 2.5.1
(function() {
  // VariantStore
  // A collection of objects and methods for working with names and their variants (i.e., nicknames)

  // constructor
  // _@variants_ - key is name, value is array of nicknames/variants
  hummingbird.VariantStore = function(variantsObj) {
    var name, norm_name;
    this.variants = {};
    this.utils = new hummingbird.Utils();
    if (variantsObj != null) {
      for (name in variantsObj) {
        norm_name = this.utils.normalizeString(name);
        this.variants[norm_name] = [];
        variantsObj[name].forEach((function(variant, i, variants) {
          var normVariant;
          normVariant = this.utils.normalizeString(variant);
          return this.variants[norm_name].push(normVariant);
        }), this);
      }
    }
  };

  // .load
  // Loads a previously serialized variant store
  hummingbird.VariantStore.load = function(serializedData) {
    var store;
    store = new (this)();
    store.variants = serializedData.hasOwnProperty('variants') ? serializedData.variants : void 0;
    return store;
  };

  // toJSON
  // Returns a representation of the variant store ready for serialization.
  hummingbird.VariantStore.prototype.toJSON = function() {
    return {
      variants: this.variants
    };
  };

  // getVariantTokens
  // Returns tokens associated with variants of the provided name
  // that would not otherwise be associated with the provided name.
  hummingbird.VariantStore.prototype.getVariantTokens = function(name, tokenizer, tokens) {
    var matched_variants, norm_name, variant_tokens;
    matched_variants = [];
    variant_tokens = {};
    norm_name = this.utils.normalizeString(name);
    if ((norm_name == null) || norm_name === undefined) {
      return variant_tokens;
    }
    // first check to see if the norm_name has variants
    if (this.variants.hasOwnProperty(norm_name)) {
      this.variants[norm_name].forEach((function(variant, i, variants) {
        var k, len, ref, results, token;
        ref = tokenizer.tokenize(variant);
        results = [];
        for (k = 0, len = ref.length; k < len; k++) {
          token = ref[k];
          if (tokens.indexOf(token) === -1) {
            results.push(variant_tokens[token] = null);
          } else {
            results.push(void 0);
          }
        }
        return results;
      }), this);
    }
    // then split the full name on word boundaries and check each name part
    if (norm_name !== norm_name.split(/\s+/)[0]) {
      norm_name.split(/\s+/).forEach((function(name_part, j, names) {
        // check each name word for any nicknames/variants
        if (this.variants.hasOwnProperty(name_part)) {
          return this.variants[name_part].forEach((function(variant, i, variants) {
            var k, len, ref, results, token;
            ref = tokenizer.tokenize(variant);
            results = [];
            for (k = 0, len = ref.length; k < len; k++) {
              token = ref[k];
              if (tokens.indexOf(token) === -1) {
                results.push(variant_tokens[token] = null);
              } else {
                results.push(void 0);
              }
            }
            return results;
          }), this);
        }
      }), this);
    }
    return Object.keys(variant_tokens);
  };

}).call(this);
